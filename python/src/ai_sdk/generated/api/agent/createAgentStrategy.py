# generated by datamodel-codegen:
#   filename:  createAgentStrategy.json
#   timestamp: 2026-02-01T09:43:59+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, List, Optional
from uuid import UUID

from pydantic import AwareDatetime, BaseModel, ConfigDict, Field, RootModel
from typing_extensions import Annotated

from . import createAgentRequest


class AgentNodeType(Enum):
    DO_NOTHING = 'DO_NOTHING'
    NODE_UPDATE_PROMPT = 'NODE_UPDATE_PROMPT'
    LLM_REQUEST = 'LLM_REQUEST'
    LLM_REQUEST_ONLY_CALLING_TOOLS = 'LLM_REQUEST_ONLY_CALLING_TOOLS'
    LLM_REQUEST_FORCE_ONE_TOOL = 'LLM_REQUEST_FORCE_ONE_TOOL'
    LLM_REQUEST_STRUCTURED = 'LLM_REQUEST_STRUCTURED'
    LLM_REQUEST_STREAMING = 'LLM_REQUEST_STREAMING'
    LLM_REQUEST_STREAMING_SEND_RESULT = 'LLM_REQUEST_STREAMING_SEND_RESULT'
    LLM_REQUEST_MULTIPLE = 'LLM_REQUEST_MULTIPLE'
    LLM_MODERATE_MESSAGE = 'LLM_MODERATE_MESSAGE'
    LLM_COMPRESS_HISTORY = 'LLM_COMPRESS_HISTORY'
    EXECUTE_TOOL = 'EXECUTE_TOOL'
    EXECUTE_TOOLS_AND_SEND_RESULT = 'EXECUTE_TOOLS_AND_SEND_RESULT'
    EXECUTE_MULTIPLE_TOOLS = 'EXECUTE_MULTIPLE_TOOLS'
    EXECUTE_SINGLE_TOOL = 'EXECUTE_SINGLE_TOOL'
    CAPTURE_AND_REPORT_TOOL_RESULT = 'CAPTURE_AND_REPORT_TOOL_RESULT'
    SEND_TOOL_RESULT = 'SEND_TOOL_RESULT'
    SEND_MULTIPLE_TOOL_RESULTS = 'SEND_MULTIPLE_TOOL_RESULTS'
    NODE_SET_STRUCTURED_OUTPUT = 'NODE_SET_STRUCTURED_OUTPUT'
    CUSTOM_NODE = 'CUSTOM_NODE'
    START_NODE = 'START_NODE'
    FINISH_NODE = 'FINISH_NODE'


class Type(Enum):
    STRING = 'STRING'
    MESSAGE = 'MESSAGE'
    MESSAGE_RESPONSE = 'MESSAGE_RESPONSE'
    MESSAGE_RESPONSE_LIST = 'MESSAGE_RESPONSE_LIST'
    MESSAGE_ASSISTANT = 'MESSAGE_ASSISTANT'
    TOOL_CALL = 'TOOL_CALL'
    TOOL_CALL_LIST = 'TOOL_CALL_LIST'
    TOOL_RESULT = 'TOOL_RESULT'
    TOOL_RESULT_LIST = 'TOOL_RESULT_LIST'
    STRUCTURED_DATA = 'STRUCTURED_DATA'
    RESULT_STRUCTURED_RESPONSE = 'RESULT_STRUCTURED_RESPONSE'
    STREAM = 'STREAM'
    FLOW_STREAM_FRAME = 'FLOW_STREAM_FRAME'
    FLOW_GENERIC = 'FLOW_GENERIC'
    MODERATED_MESSAGE = 'MODERATED_MESSAGE'
    SAFE_TOOL_RESULT = 'SAFE_TOOL_RESULT'
    SAFE_TOOL_RESULT_SUCCESS = 'SAFE_TOOL_RESULT_SUCCESS'
    SAFE_TOOL_RESULT_FAILURE = 'SAFE_TOOL_RESULT_FAILURE'
    BOOLEAN = 'BOOLEAN'
    NUMBER = 'NUMBER'
    JSON_OBJECT = 'JSON_OBJECT'
    GENERIC_TYPE = 'GENERIC_TYPE'
    VOID = 'VOID'


class NodeIOSchema(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Annotated[Type, Field(description='The data type of the input/output')]
    description: Annotated[
        Optional[str],
        Field(None, description='Human-readable description of this input/output'),
    ]
    required: Annotated[
        Optional[bool], Field(True, description='Whether this input is required')
    ]
    structuredSchema: Annotated[
        Optional[Any], Field(None, description='JSON schema for structured data types.')
    ]


class NodePosition(BaseModel):
    x: Optional[float] = None
    y: Optional[float] = None


class EdgeCondition(Enum):
    ON_TOOL_CALL = 'ON_TOOL_CALL'
    ON_ASSISTANT_MESSAGE = 'ON_ASSISTANT_MESSAGE'
    ON_SUCCESS = 'ON_SUCCESS'
    ON_ERROR = 'ON_ERROR'
    ALWAYS = 'ALWAYS'
    CUSTOM_CONDITION = 'CUSTOM_CONDITION'


class LabelType(Enum):
    Manual = 'Manual'
    Propagated = 'Propagated'
    Automated = 'Automated'
    Derived = 'Derived'
    Generated = 'Generated'


class State(Enum):
    Suggested = 'Suggested'
    Confirmed = 'Confirmed'


class Target(Enum):
    content = 'content'
    column_name = 'column_name'


class PatternMatch(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Annotated[str, Field(description='Name of the pattern that matched')]
    regex: Annotated[
        Optional[str],
        Field(None, description='Regular expression or pattern definition'),
    ]
    score: Annotated[
        float,
        Field(
            description='Confidence score for this specific pattern match',
            ge=0.0,
            le=1.0,
        ),
    ]


class TagFQN(RootModel[str]):
    root: str


class TagSource(Enum):
    Classification = 'Classification'
    Glossary = 'Glossary'


class EntityReference(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[
        createAgentRequest.Uuid,
        Field(description='Unique identifier that identifies an entity instance.'),
    ]
    type: Annotated[
        str,
        Field(
            description='Entity type/class name - Examples: `database`, `table`, `metrics`, `databaseService`, `dashboardService`...'
        ),
    ]
    name: Annotated[
        Optional[str], Field(None, description='Name of the entity instance.')
    ]
    fullyQualifiedName: Annotated[
        Optional[str],
        Field(
            None,
            description="Fully qualified name of the entity instance. For entities such as tables, databases fullyQualifiedName is returned in this field. For entities that don't have name hierarchy such as `user` and `team` this will be same as the `name` field.",
        ),
    ]
    description: Annotated[
        Optional[createAgentRequest.Markdown],
        Field(None, description='Optional description of entity.'),
    ]
    displayName: Annotated[
        Optional[str],
        Field(None, description='Display Name that identifies this entity.'),
    ]
    deleted: Annotated[
        Optional[bool],
        Field(
            None, description='If true the entity referred to has been soft-deleted.'
        ),
    ]
    inherited: Annotated[
        Optional[bool],
        Field(
            None,
            description='If true the relationship indicated by this entity reference is inherited from the parent entity.',
        ),
    ]
    href: Annotated[
        Optional[createAgentRequest.Href],
        Field(None, description='Link to the entity resource.'),
    ]


class AgentNode(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[
        Optional[UUID], Field(None, description='Unique identifier for the node')
    ]
    name: Annotated[str, Field(description='Human-readable name for the node')]
    displayName: Annotated[
        Optional[str], Field(None, description='Display Name for the Node.')
    ]
    description: Annotated[
        Optional[str], Field(None, description='Description for the Node.')
    ]
    nodeType: Annotated[
        Optional[AgentNodeType], Field(None, description='Type of the node')
    ]
    icon: Annotated[Optional[str], Field(None, description='Icon for the node')]
    categoryLabel: Annotated[
        Optional[str], Field(None, description='Category label for the node')
    ]
    inputSchema: Annotated[
        Optional[NodeIOSchema], Field(None, description='Input Schema for Node')
    ]
    outputSchema: Annotated[
        Optional[NodeIOSchema], Field(None, description='Output Schema for Node')
    ]
    configurationSchema: Annotated[
        Optional[Any], Field(None, description='Node-specific configuration parameters')
    ]
    defaultConfiguration: Annotated[
        Optional[Any], Field(None, description='Node-specific configuration parameters')
    ]
    position: Optional[NodePosition] = None
    provider: Annotated[
        Optional[createAgentRequest.ProviderType],
        Field(
            createAgentRequest.ProviderType.user,
            description='Provider of the Ability implementation',
        ),
    ]


class AgentEdge(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    source: Annotated[UUID, Field(description='Source node ID')]
    target: Annotated[UUID, Field(description='Target node ID')]
    condition: Annotated[
        EdgeCondition, Field(description='Condition for this edge to be taken')
    ]
    conditionExpression: Annotated[
        Optional[str],
        Field(
            None,
            description='Custom condition expression if condition is CUSTOM_CONDITION',
        ),
    ]
    transformation: Annotated[
        Optional[str],
        Field(None, description='Optional transformation function to apply to data'),
    ]


class TagLabelRecognizerMetadata(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    recognizerId: Annotated[
        createAgentRequest.Uuid,
        Field(description='Unique identifier of the recognizer that applied this tag'),
    ]
    recognizerName: Annotated[
        str, Field(description='Human-readable name of the recognizer')
    ]
    score: Annotated[
        float,
        Field(
            description='Confidence score assigned by the recognizer (0.0 to 1.0)',
            ge=0.0,
            le=1.0,
        ),
    ]
    target: Annotated[
        Optional[Target],
        Field(None, description='What the recognizer analyzed to apply this tag'),
    ]
    patterns: Annotated[
        Optional[List[PatternMatch]],
        Field(None, description='Details of patterns that matched during recognition'),
    ]


class TagLabelMetadata(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    recognizer: Annotated[
        Optional[TagLabelRecognizerMetadata],
        Field(
            None,
            description='Metadata about the recognizer that automatically applied this tag',
        ),
    ]


class TagLabel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    tagFQN: TagFQN
    name: Annotated[
        Optional[str], Field(None, description='Name of the tag or glossary term.')
    ]
    displayName: Annotated[
        Optional[str], Field(None, description='Display Name that identifies this tag.')
    ]
    description: Annotated[
        Optional[createAgentRequest.Markdown],
        Field(None, description='Description for the tag label.'),
    ]
    style: Optional[createAgentRequest.Style] = None
    source: Annotated[TagSource, Field(description='Label is from Tags or Glossary.')]
    labelType: Annotated[
        LabelType,
        Field(
            description="Label type describes how a tag label was applied. 'Manual' indicates the tag label was applied by a person. 'Derived' indicates a tag label was derived using the associated tag relationship (see Classification.json for more details). 'Propagated` indicates a tag label was propagated from upstream based on lineage. 'Automated' is used when a tool was used to determine the tag label."
        ),
    ]
    state: Annotated[
        State,
        Field(
            description="'Suggested' state is used when a tag label is suggested by users or tools. Owner of the entity must confirm the suggested labels before it is marked as 'Confirmed'."
        ),
    ]
    href: Annotated[
        Optional[createAgentRequest.Href],
        Field(None, description='Link to the tag resource.'),
    ]
    reason: Annotated[
        Optional[str],
        Field(
            None,
            description='An explanation of why this tag was proposed, specially for autoclassification tags',
        ),
    ]
    appliedAt: Annotated[
        Optional[AwareDatetime],
        Field(
            None, description='Timestamp when this tag was applied in ISO 8601 format'
        ),
    ]
    appliedBy: Annotated[
        Optional[str],
        Field(
            None,
            description='Who it is that applied this tag (e.g: a bot, AI or a human)',
        ),
    ]
    metadata: Annotated[
        Optional[TagLabelMetadata],
        Field(
            None,
            description='Additional metadata associated with this tag label, such as recognizer information for automatically applied tags.',
        ),
    ]


class CreateAgentStrategy(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Annotated[
        Optional[createAgentRequest.EntityName],
        Field(None, description='A unique name of the Agent Strategy'),
    ]
    fullyQualifiedName: Annotated[
        Optional[createAgentRequest.FullyQualifiedEntityName],
        Field(None, description='FullyQualifiedName same as `name`.'),
    ]
    displayName: Annotated[
        Optional[str],
        Field(
            None,
            description="Name used for display purposes. Example 'Simple Q&A', 'Tool Calling Agent', etc.",
        ),
    ]
    description: Annotated[
        Optional[createAgentRequest.Markdown],
        Field(None, description='Description of the strategy and its use case.'),
    ]
    nodes: Annotated[
        Optional[List[AgentNode]],
        Field(
            None, description="Workflow nodes that define the agent's execution steps"
        ),
    ]
    edges: Annotated[
        Optional[List[AgentEdge]],
        Field(
            None,
            description='Workflow edges that define transitions and data flow between nodes',
        ),
    ]
    provider: Annotated[
        Optional[createAgentRequest.ProviderType],
        Field(
            createAgentRequest.ProviderType.user,
            description='Provider of the Ability implementation',
        ),
    ]
    tags: Annotated[
        Optional[List[TagLabel]], Field([], description='Tags for this Agent Strategy.')
    ]
    owner: Annotated[
        Optional[EntityReference],
        Field(None, description='Owner of this Agent Strategy'),
    ]
    deleted: Annotated[
        Optional[bool],
        Field(
            False, description='When `true` indicates the entity has been soft deleted.'
        ),
    ]
