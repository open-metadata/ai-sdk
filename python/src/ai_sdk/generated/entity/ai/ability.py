# generated by datamodel-codegen:
#   filename:  ability.json
#   timestamp: 2026-02-01T09:44:00+00:00

from __future__ import annotations

from datetime import date, time
from enum import Enum
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import (
    AnyUrl,
    AwareDatetime,
    BaseModel,
    ConfigDict,
    EmailStr,
    Field,
    RootModel,
)
from typing_extensions import Annotated


class Uuid(RootModel[UUID]):
    root: Annotated[UUID, Field(description='Unique id used to identify an entity.')]


class Integer(RootModel[int]):
    root: Annotated[int, Field(description='An integer type.')]


class Number(RootModel[float]):
    root: Annotated[
        float,
        Field(
            description='A numeric type that includes integer or floating point numbers.'
        ),
    ]


class String(RootModel[str]):
    root: Annotated[str, Field(description='A String type.')]


class Email(RootModel[EmailStr]):
    root: Annotated[
        EmailStr,
        Field(
            description='Email address of a user or other entities.',
            max_length=127,
            min_length=6,
            pattern='^[\\S.!#$%&â€™*+/=?^_`{|}~-]+@\\S+\\.\\S+$',
        ),
    ]


class Timestamp(RootModel[int]):
    root: Annotated[
        int, Field(description='Timestamp in Unix epoch time milliseconds.')
    ]


class Href(RootModel[AnyUrl]):
    root: Annotated[AnyUrl, Field(description='URI that points to a resource.')]


class TimeInterval(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    start: Annotated[
        Optional[int], Field(None, description='Start time in unixTimeMillis.')
    ]
    end: Annotated[
        Optional[int], Field(None, description='End time in unixTimeMillis.')
    ]


class Duration(RootModel[str]):
    root: Annotated[
        str,
        Field(description="Duration in ISO 8601 format in UTC. Example - 'P23DT23H'."),
    ]


class Date(RootModel[date]):
    root: Annotated[
        date,
        Field(description="Date in ISO 8601 format in UTC. Example - '2018-11-13'."),
    ]


class ImpersonatedBy(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='Bot user that performed the action on behalf of the actual user.'
        ),
    ]


class DateTime(RootModel[AwareDatetime]):
    root: Annotated[
        AwareDatetime,
        Field(
            description="Date and time in ISO 8601 format. Example - '2018-11-13T20:20:39+00:00'."
        ),
    ]


class Time(RootModel[time]):
    root: Annotated[
        time, Field(description="time in ISO 8601 format. Example - '20:20:39+00:00'.")
    ]


class DateCp(RootModel[str]):
    root: Annotated[str, Field(description='Date as defined in custom property.')]


class DateTimeCp(RootModel[str]):
    root: Annotated[
        str, Field(description='Date and time as defined in custom property.')
    ]


class TimeCp(RootModel[str]):
    root: Annotated[str, Field(description='Time as defined in custom property.')]


class EnumModel(RootModel[List[str]]):
    root: Annotated[List[str], Field(description='List of values in Enum.')]


class Timezone(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='Timezone of the user in the format `America/Los_Angeles`, `Brazil/East`, etc.'
        ),
    ]


class EntityLink(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='Link to an entity or field within an entity using this format `<#E::{entities}::{entityType}::{field}::{arrayFieldName}::{arrayFieldValue}`.',
            pattern='(?U)^<#E::\\w+::(?:[^:<>|]|:[^:<>|])+(?:::(?:[^:<>|]|:[^:<>|])+)*>$',
        ),
    ]


class EntityName(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='Name that identifies an entity.',
            max_length=256,
            min_length=1,
            pattern='^((?!::).)*$',
        ),
    ]


class TestCaseEntityName(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='Name that identifies a test definition and test case.',
            min_length=1,
            pattern='^((?!::).)*$',
        ),
    ]


class FullyQualifiedEntityName(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description="A unique name that identifies an entity. Example for table 'DatabaseService.Database.Schema.Table'.",
            max_length=3072,
            min_length=1,
        ),
    ]


class SqlQuery(RootModel[str]):
    root: Annotated[
        str, Field(description="SQL query statement. Example - 'select * from orders'.")
    ]


class SqlFunction(RootModel[str]):
    root: Annotated[
        str, Field(description="SQL function. Example - 'AVG()`, `COUNT()`, etc..")
    ]


class Markdown(RootModel[str]):
    root: Annotated[str, Field(description='Text in Markdown format.')]


class Expression(RootModel[str]):
    root: Annotated[str, Field(description='Expression in SpEL.')]


class JsonSchema(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='JSON schema encoded as string. This will be used to validate the JSON fields using this schema.'
        ),
    ]


class EntityExtension(RootModel[Any]):
    root: Annotated[
        Any,
        Field(
            description='Entity extension data with custom attributes added to the entity.'
        ),
    ]


class ProviderType(Enum):
    system = 'system'
    user = 'user'
    automation = 'automation'


class ComponentConfig(RootModel[Optional[Dict[str, Any]]]):
    root: Optional[Dict[str, Any]] = None


class Map(BaseModel):
    pass
    model_config = ConfigDict(
        extra='allow',
    )


class Status1(Enum):
    success = 'success'
    failure = 'failure'
    aborted = 'aborted'
    partialSuccess = 'partialSuccess'
    running = 'running'


class SourceUrl(RootModel[str]):
    root: Annotated[str, Field(description='Source Url of the respective entity.')]


class CoverImage(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    url: Annotated[Optional[str], Field(None, description='URL of the cover image.')]
    position: Annotated[
        Optional[str],
        Field(
            None,
            description="Position of the cover image in CSS background-position format. Supports keywords (top, center, bottom) or pixel values (e.g., '20px 30px').",
        ),
    ]


class Style(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    color: Annotated[
        Optional[str],
        Field(
            None,
            description='Hex Color Code to mark an entity such as GlossaryTerm, Tag, Domain or Data Product.',
        ),
    ]
    iconURL: Annotated[
        Optional[str],
        Field(
            None,
            description='An icon to associate with GlossaryTerm, Tag, Domain or Data Product.',
        ),
    ]
    coverImage: Annotated[
        Optional[CoverImage],
        Field(None, description='Cover image configuration for the entity.'),
    ]


class SemanticsRule(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Annotated[
        str, Field(description='Name of the semantics rule.', title='Rule Name')
    ]
    description: Annotated[
        Markdown,
        Field(
            description='Description of the semantics rule.', title='Rule Description'
        ),
    ]
    rule: Annotated[
        str,
        Field(description='Definition of the semantics rule.', title='Rule Definition'),
    ]
    enabled: Annotated[
        bool,
        Field(
            description='Indicates if the semantics rule is enabled.', title='Enabled'
        ),
    ]
    entityType: Annotated[
        Optional[str],
        Field(
            None,
            description='Type of the entity to which this semantics rule applies.',
            title='Entity Type',
        ),
    ]
    ignoredEntities: Annotated[
        Optional[List[str]],
        Field(
            [],
            description='List of entities to ignore for this semantics rule.',
            title='Ignored Entities',
        ),
    ]
    jsonTree: Annotated[
        Optional[str],
        Field(
            None,
            description='JSON Tree to represents rule in UI.',
            title='JSON Tree to represents rule in UI.',
        ),
    ]
    provider: Optional[ProviderType] = ProviderType.user
    inherited: Annotated[
        Optional[bool],
        Field(
            False,
            description='Whether this rule was inherited from a Data Product.',
            title='Inherited',
        ),
    ]


class EntityVersion(RootModel[float]):
    root: Annotated[
        float,
        Field(
            description='Metadata version of the entity in the form `Major.Minor`. First version always starts from `0.1` when the entity is created. When the backward compatible changes are made to the entity, only the `Minor` version is incremented - example `1.0` is changed to `1.1`. When backward incompatible changes are made the `Major` version is incremented - example `1.1` to `2.0`.',
            ge=0.1,
            multiple_of=0.1,
        ),
    ]


class FieldName(RootModel[str]):
    root: Annotated[str, Field(description='Name of the field of an entity.')]


class FieldChange(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Annotated[
        Optional[FieldName],
        Field(None, description='Name of the entity field that changed.'),
    ]
    oldValue: Annotated[
        Optional[Any],
        Field(
            None,
            description='Previous value of the field. Note that this is a JSON string and use the corresponding field type to deserialize it.',
        ),
    ]
    newValue: Annotated[
        Optional[Any],
        Field(
            None,
            description='New value of the field. Note that this is a JSON string and use the corresponding field type to deserialize it.',
        ),
    ]


class ChangeSource(Enum):
    Manual = 'Manual'
    Propagated = 'Propagated'
    Automated = 'Automated'
    Derived = 'Derived'
    Ingested = 'Ingested'
    Suggested = 'Suggested'


class ChangeSummary(BaseModel):
    changeSource: Optional[ChangeSource] = ChangeSource.Manual
    changedBy: Annotated[
        Optional[str],
        Field(None, description='Name of the user or bot who made this change'),
    ]
    changedAt: Optional[Timestamp] = None


class IncrementalChangeDescription(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fieldsAdded: Annotated[
        Optional[List[FieldChange]],
        Field(None, description='Names of fields added during the version changes.'),
    ]
    fieldsUpdated: Annotated[
        Optional[List[FieldChange]],
        Field(
            None,
            description='Fields modified during the version changes with old and new values.',
        ),
    ]
    fieldsDeleted: Annotated[
        Optional[List[FieldChange]],
        Field(
            None,
            description='Fields deleted during the version changes with old value before deleted.',
        ),
    ]
    previousVersion: Annotated[
        Optional[EntityVersion],
        Field(
            None,
            description='When a change did not result in change, this could be same as the current version.',
        ),
    ]


class EntityReference(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[
        Uuid, Field(description='Unique identifier that identifies an entity instance.')
    ]
    type: Annotated[
        str,
        Field(
            description='Entity type/class name - Examples: `database`, `table`, `metrics`, `databaseService`, `dashboardService`...'
        ),
    ]
    name: Annotated[
        Optional[str], Field(None, description='Name of the entity instance.')
    ]
    fullyQualifiedName: Annotated[
        Optional[str],
        Field(
            None,
            description="Fully qualified name of the entity instance. For entities such as tables, databases fullyQualifiedName is returned in this field. For entities that don't have name hierarchy such as `user` and `team` this will be same as the `name` field.",
        ),
    ]
    description: Annotated[
        Optional[Markdown], Field(None, description='Optional description of entity.')
    ]
    displayName: Annotated[
        Optional[str],
        Field(None, description='Display Name that identifies this entity.'),
    ]
    deleted: Annotated[
        Optional[bool],
        Field(
            None, description='If true the entity referred to has been soft-deleted.'
        ),
    ]
    inherited: Annotated[
        Optional[bool],
        Field(
            None,
            description='If true the relationship indicated by this entity reference is inherited from the parent entity.',
        ),
    ]
    href: Annotated[
        Optional[Href], Field(None, description='Link to the entity resource.')
    ]


class LabelType(Enum):
    Manual = 'Manual'
    Propagated = 'Propagated'
    Automated = 'Automated'
    Derived = 'Derived'
    Generated = 'Generated'


class State(Enum):
    Suggested = 'Suggested'
    Confirmed = 'Confirmed'


class Target(Enum):
    content = 'content'
    column_name = 'column_name'


class PatternMatch(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Annotated[str, Field(description='Name of the pattern that matched')]
    regex: Annotated[
        Optional[str],
        Field(None, description='Regular expression or pattern definition'),
    ]
    score: Annotated[
        float,
        Field(
            description='Confidence score for this specific pattern match',
            ge=0.0,
            le=1.0,
        ),
    ]


class TagFQN(RootModel[str]):
    root: str


class TagSource(Enum):
    Classification = 'Classification'
    Glossary = 'Glossary'


class Status(Enum):
    Draft = 'Draft'
    In_Review = 'In Review'
    Approved = 'Approved'
    Deprecated = 'Deprecated'
    Rejected = 'Rejected'
    Unprocessed = 'Unprocessed'


class ChangeSummaryMap(RootModel[Optional[Dict[str, ChangeSummary]]]):
    root: Optional[Dict[str, ChangeSummary]] = None


class EntityReferenceList(RootModel[List[EntityReference]]):
    root: Annotated[
        List[EntityReference],
        Field(
            description='This schema defines the EntityReferenceList type used for referencing an entity. EntityReference is used for capturing relationships from one entity to another. For example, a table has an attribute called database of type EntityReference that captures the relationship of a table `belongs to a` database.',
            title='Entity Reference List',
        ),
    ]


class TagLabelRecognizerMetadata(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    recognizerId: Annotated[
        Uuid,
        Field(description='Unique identifier of the recognizer that applied this tag'),
    ]
    recognizerName: Annotated[
        str, Field(description='Human-readable name of the recognizer')
    ]
    score: Annotated[
        float,
        Field(
            description='Confidence score assigned by the recognizer (0.0 to 1.0)',
            ge=0.0,
            le=1.0,
        ),
    ]
    target: Annotated[
        Optional[Target],
        Field(None, description='What the recognizer analyzed to apply this tag'),
    ]
    patterns: Annotated[
        Optional[List[PatternMatch]],
        Field(None, description='Details of patterns that matched during recognition'),
    ]


class ChangeDescription(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fieldsAdded: Annotated[
        Optional[List[FieldChange]],
        Field(None, description='Names of fields added during the version changes.'),
    ]
    fieldsUpdated: Annotated[
        Optional[List[FieldChange]],
        Field(
            None,
            description='Fields modified during the version changes with old and new values.',
        ),
    ]
    fieldsDeleted: Annotated[
        Optional[List[FieldChange]],
        Field(
            None,
            description='Fields deleted during the version changes with old value before deleted.',
        ),
    ]
    previousVersion: Annotated[
        Optional[EntityVersion],
        Field(
            None,
            description='When a change did not result in change, this could be same as the current version.',
        ),
    ]
    changeSummary: Optional[ChangeSummaryMap] = None


class TagLabelMetadata(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    recognizer: Annotated[
        Optional[TagLabelRecognizerMetadata],
        Field(
            None,
            description='Metadata about the recognizer that automatically applied this tag',
        ),
    ]


class TagLabel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    tagFQN: TagFQN
    name: Annotated[
        Optional[str], Field(None, description='Name of the tag or glossary term.')
    ]
    displayName: Annotated[
        Optional[str], Field(None, description='Display Name that identifies this tag.')
    ]
    description: Annotated[
        Optional[Markdown], Field(None, description='Description for the tag label.')
    ]
    style: Optional[Style] = None
    source: Annotated[TagSource, Field(description='Label is from Tags or Glossary.')]
    labelType: Annotated[
        LabelType,
        Field(
            description="Label type describes how a tag label was applied. 'Manual' indicates the tag label was applied by a person. 'Derived' indicates a tag label was derived using the associated tag relationship (see Classification.json for more details). 'Propagated` indicates a tag label was propagated from upstream based on lineage. 'Automated' is used when a tool was used to determine the tag label."
        ),
    ]
    state: Annotated[
        State,
        Field(
            description="'Suggested' state is used when a tag label is suggested by users or tools. Owner of the entity must confirm the suggested labels before it is marked as 'Confirmed'."
        ),
    ]
    href: Annotated[
        Optional[Href], Field(None, description='Link to the tag resource.')
    ]
    reason: Annotated[
        Optional[str],
        Field(
            None,
            description='An explanation of why this tag was proposed, specially for autoclassification tags',
        ),
    ]
    appliedAt: Annotated[
        Optional[AwareDatetime],
        Field(
            None, description='Timestamp when this tag was applied in ISO 8601 format'
        ),
    ]
    appliedBy: Annotated[
        Optional[str],
        Field(
            None,
            description='Who it is that applied this tag (e.g: a bot, AI or a human)',
        ),
    ]
    metadata: Annotated[
        Optional[TagLabelMetadata],
        Field(
            None,
            description='Additional metadata associated with this tag label, such as recognizer information for automatically applied tags.',
        ),
    ]


class Ability(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[Uuid, Field(description='Unique ID of the Ability')]
    name: Annotated[EntityName, Field(description='A unique name of the Ability')]
    fullyQualifiedName: Annotated[
        Optional[FullyQualifiedEntityName],
        Field(None, description='FullyQualifiedName same as `name`.'),
    ]
    displayName: Annotated[
        Optional[str],
        Field(
            None,
            description="Name used for display purposes. Example 'Semantic Search', 'Send Slack Message', etc.",
        ),
    ]
    description: Annotated[
        Markdown, Field(description='Description of the Ability and its capabilities.')
    ]
    tools: Annotated[
        List[str], Field(description='List of tools that this ability depends on.')
    ]
    provider: Annotated[
        ProviderType, Field(description='Provider of the Ability implementation')
    ]
    version: Annotated[
        Optional[EntityVersion],
        Field(None, description='Metadata version of the entity.'),
    ]
    updatedAt: Annotated[
        Optional[Timestamp],
        Field(
            None,
            description='Last update time corresponding to the new version of the entity in Unix epoch time milliseconds.',
        ),
    ]
    updatedBy: Annotated[
        Optional[str], Field(None, description='User who made the update.')
    ]
    href: Annotated[
        Optional[Href],
        Field(None, description='Link to the resource corresponding to this entity.'),
    ]
    owners: Annotated[
        Optional[EntityReferenceList],
        Field(None, description='Owners of this Ability.'),
    ]
    tags: Annotated[
        Optional[List[TagLabel]],
        Field([], description='Tags associated with the Ability.'),
    ]
    changeDescription: Annotated[
        Optional[ChangeDescription],
        Field(None, description='Change that lead to this version of the entity.'),
    ]
    incrementalChangeDescription: Annotated[
        Optional[ChangeDescription],
        Field(
            None,
            description='Entity extension data with custom attributes added to the entity.',
        ),
    ]
    extension: Annotated[
        Optional[EntityExtension],
        Field(
            None,
            description='Entity extension data with custom attributes added to the entity.',
        ),
    ]
    reviewers: Annotated[
        Optional[EntityReferenceList],
        Field(None, description='User references of the reviewers for this Ability.'),
    ]
    entityStatus: Annotated[
        Optional[Status], Field(Status.Approved, description='Status of the Ability.')
    ]
    followers: Annotated[
        Optional[EntityReferenceList],
        Field(None, description='Followers of this entity.'),
    ]
    deleted: Annotated[
        Optional[bool],
        Field(
            False, description='When `true` indicates the entity has been soft deleted.'
        ),
    ]
