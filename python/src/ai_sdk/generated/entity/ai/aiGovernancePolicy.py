# generated by datamodel-codegen:
#   filename:  aiGovernancePolicy.json
#   timestamp: 2026-02-01T09:44:00+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, ConfigDict, Field
from typing_extensions import Annotated

from . import ability, aiApplication


class EnforcementLevel(Enum):
    Advisory = 'Advisory'
    Warning = 'Warning'
    Blocking = 'Blocking'


class PolicyType(Enum):
    ModelApproval = 'ModelApproval'
    DataAccess = 'DataAccess'
    BiasThreshold = 'BiasThreshold'
    ComplianceCheck = 'ComplianceCheck'
    CostControl = 'CostControl'
    PerformanceStandard = 'PerformanceStandard'
    SecurityControl = 'SecurityControl'


class RuleType(Enum):
    Threshold = 'Threshold'
    Approval = 'Approval'
    Prohibition = 'Prohibition'
    Requirement = 'Requirement'
    Notification = 'Notification'


class Action(Enum):
    Block = 'Block'
    Warn = 'Warn'
    Notify = 'Notify'
    Require_Approval = 'Require_Approval'
    Log = 'Log'


class Severity(Enum):
    Low = 'Low'
    Medium = 'Medium'
    High = 'High'
    Critical = 'Critical'


class PolicyRule(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Annotated[str, Field(description='Rule name')]
    description: Annotated[Optional[str], Field(None, description='Rule description')]
    ruleType: Annotated[RuleType, Field(description='Type of rule')]
    condition: Annotated[
        Optional[str],
        Field(None, description="Condition expression (e.g., 'biasScore > 0.3')"),
    ]
    action: Annotated[
        Action, Field(description='Action to take when rule is triggered')
    ]
    severity: Optional[Severity] = None
    enabled: Optional[bool] = True


class DimensionThresholds(BaseModel):
    gender: Optional[float] = None
    race: Optional[float] = None
    age: Optional[float] = None
    religion: Optional[float] = None
    disability: Optional[float] = None
    nationality: Optional[float] = None
    socioeconomic: Optional[float] = None


class EvaluationFrequency(Enum):
    Continuous = 'Continuous'
    Daily = 'Daily'
    Weekly = 'Weekly'
    Monthly = 'Monthly'
    OnDemand = 'OnDemand'


class BiasThreshold(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    maxOverallBiasScore: Annotated[
        Optional[float],
        Field(None, description='Maximum allowed overall bias score (0-1)'),
    ]
    dimensionThresholds: Annotated[
        Optional[DimensionThresholds],
        Field(None, description='Maximum bias scores per dimension'),
    ]
    evaluationFrequency: Annotated[
        Optional[EvaluationFrequency],
        Field(None, description='How often to evaluate bias'),
    ]


class MaxSensitivityLevel(Enum):
    Public = 'Public'
    Internal = 'Internal'
    Confidential = 'Confidential'
    Restricted = 'Restricted'


class CostControl(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    dailyBudget: Annotated[
        Optional[float], Field(None, description='Maximum daily spend in USD')
    ]
    monthlyBudget: Annotated[
        Optional[float], Field(None, description='Maximum monthly spend in USD')
    ]
    perExecutionLimit: Annotated[
        Optional[float], Field(None, description='Maximum cost per execution')
    ]
    warningThreshold: Annotated[
        Optional[float],
        Field(None, description='Percentage threshold for warnings (0-100)'),
    ]
    currency: Optional[str] = 'USD'


class Standard(Enum):
    GDPR = 'GDPR'
    HIPAA = 'HIPAA'
    SOC2 = 'SOC2'
    ISO27001 = 'ISO27001'
    NIST_AI_RMF = 'NIST_AI_RMF'
    EU_AI_Act = 'EU_AI_Act'
    OWASP_LLM_Top10 = 'OWASP_LLM_Top10'
    Custom = 'Custom'


class AuditFrequency(Enum):
    Continuous = 'Continuous'
    Weekly = 'Weekly'
    Monthly = 'Monthly'
    Quarterly = 'Quarterly'
    Annually = 'Annually'


class ComplianceRequirement(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    standard: Annotated[
        Optional[Standard], Field(None, description='Compliance standard')
    ]
    requirements: Annotated[
        Optional[List[str]], Field(None, description='Specific requirements')
    ]
    attestationRequired: Annotated[
        Optional[bool], Field(False, description='Whether attestation is required')
    ]
    auditFrequency: Optional[AuditFrequency] = None


class PerformanceStandard(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    minAccuracy: Annotated[
        Optional[float], Field(None, description='Minimum required accuracy (0-1)')
    ]
    maxLatencyMs: Annotated[
        Optional[float],
        Field(None, description='Maximum allowed latency in milliseconds'),
    ]
    minSuccessRate: Annotated[
        Optional[float], Field(None, description='Minimum success rate (0-1)')
    ]
    maxErrorRate: Annotated[
        Optional[float], Field(None, description='Maximum error rate (0-1)')
    ]
    evaluationDataset: Annotated[
        Optional[ability.EntityReference],
        Field(None, description='Dataset to use for evaluation'),
    ]


class PolicyViolation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    violatedRule: Annotated[
        Optional[str], Field(None, description='Name of the violated rule')
    ]
    violatingEntity: Annotated[
        Optional[ability.EntityReference],
        Field(None, description='Entity that violated the policy'),
    ]
    timestamp: Optional[ability.Timestamp] = None
    details: Annotated[
        Optional[str], Field(None, description='Details about the violation')
    ]
    resolved: Optional[bool] = False
    resolvedBy: Optional[str] = None
    resolvedAt: Optional[ability.Timestamp] = None


class DataAccessControl(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    allowedDataSources: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='Allowed data sources'),
    ]
    prohibitedDataSources: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='Prohibited data sources'),
    ]
    maxSensitivityLevel: Annotated[
        Optional[MaxSensitivityLevel],
        Field(None, description='Maximum data sensitivity level allowed'),
    ]
    piiAccessAllowed: Annotated[
        Optional[bool], Field(False, description='Whether PII data access is allowed')
    ]
    requireApprovalForSensitiveData: Optional[bool] = True
    dataRetentionDays: Annotated[
        Optional[int],
        Field(None, description='How long execution data can be retained'),
    ]


class AIGovernancePolicy(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[
        ability.Uuid, Field(description='Unique identifier of the AI Governance Policy')
    ]
    name: Annotated[
        ability.EntityName,
        Field(description='Name that identifies this AI Governance Policy'),
    ]
    fullyQualifiedName: Annotated[
        Optional[ability.FullyQualifiedEntityName],
        Field(None, description='Fully qualified name of the AI Governance Policy'),
    ]
    displayName: Annotated[
        Optional[str],
        Field(None, description='Display name for the AI Governance Policy'),
    ]
    description: Annotated[
        Optional[ability.Markdown],
        Field(None, description='Description of the policy and its purpose'),
    ]
    policyType: PolicyType
    rules: Annotated[
        Optional[List[PolicyRule]],
        Field(None, description='Rules that make up this policy'),
    ]
    biasThresholds: Optional[BiasThreshold] = None
    dataAccessControls: Optional[DataAccessControl] = None
    costControls: Optional[CostControl] = None
    complianceRequirements: Annotated[
        Optional[List[ComplianceRequirement]],
        Field(None, description='Compliance requirements this policy enforces'),
    ]
    performanceStandards: Optional[PerformanceStandard] = None
    appliesTo: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='Entities this policy applies to'),
    ]
    enforcementLevel: Annotated[
        Optional[EnforcementLevel],
        Field(
            EnforcementLevel.Warning, description='How strictly to enforce this policy'
        ),
    ]
    enabled: Annotated[
        Optional[bool],
        Field(True, description='Whether this policy is currently active'),
    ]
    effectiveDate: Annotated[
        Optional[ability.Timestamp],
        Field(None, description='Date when policy becomes effective'),
    ]
    expirationDate: Annotated[
        Optional[ability.Timestamp], Field(None, description='Date when policy expires')
    ]
    approvedBy: Annotated[
        Optional[str], Field(None, description='Who approved this policy')
    ]
    violations: Annotated[
        Optional[List[PolicyViolation]],
        Field(None, description='Recent policy violations'),
    ]
    owners: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='Owners of this AI Governance Policy'),
    ]
    followers: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='Followers of this AI Governance Policy'),
    ]
    domain: Annotated[
        Optional[ability.EntityReference],
        Field(None, description='Domain the policy belongs to'),
    ]
    tags: Annotated[
        Optional[List[ability.TagLabel]],
        Field(None, description='Tags for this AI Governance Policy'),
    ]
    version: Annotated[
        Optional[ability.EntityVersion],
        Field(None, description='Metadata version of the entity'),
    ]
    updatedAt: Annotated[
        Optional[ability.Timestamp],
        Field(None, description='Last update time in Unix epoch milliseconds'),
    ]
    updatedBy: Annotated[
        Optional[str], Field(None, description='User who made the update')
    ]
    href: Annotated[
        Optional[ability.Href], Field(None, description='Link to this resource')
    ]
    changeDescription: Annotated[
        Optional[ability.ChangeDescription],
        Field(None, description='Change that led to this version'),
    ]
    incrementalChangeDescription: Annotated[
        Optional[ability.ChangeDescription],
        Field(None, description='Change that led to this version'),
    ]
    deleted: Annotated[
        Optional[bool],
        Field(
            False, description='When true, indicates the entity has been soft deleted'
        ),
    ]
    extension: Annotated[
        Optional[ability.EntityExtension],
        Field(None, description='Entity extension data with custom attributes'),
    ]
    domains: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='Domains the policy belongs to'),
    ]
    votes: Annotated[
        Optional[aiApplication.Votes], Field(None, description='Votes on the entity')
    ]
    lifeCycle: Annotated[
        Optional[aiApplication.LifeCycle],
        Field(None, description='Life Cycle properties of the entity'),
    ]
    sourceHash: Annotated[
        Optional[str],
        Field(
            None, description='Source hash of the entity', max_length=32, min_length=1
        ),
    ]
