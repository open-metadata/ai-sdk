# generated by datamodel-codegen:
#   filename:  dynamicAgent.json
#   timestamp: 2026-02-01T09:44:00+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, ConfigDict, Field
from typing_extensions import Annotated

from . import ability


class AgentMode(Enum):
    chat = 'chat'
    agent = 'agent'
    both = 'both'


class AssetType(Enum):
    Inline = 'Inline'
    External = 'External'


class Asset(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[str, Field(description='Unique identifier of the asset.')]
    fullyQualifiedName: Annotated[
        Optional[ability.FullyQualifiedEntityName],
        Field(
            None,
            description='Fully qualified name of a data asset the attachment belongsTo`.',
        ),
    ]
    fileName: Annotated[str, Field(description='The original file name of the asset.')]
    url: Annotated[
        Optional[str], Field(None, description='URL where the asset is accessible.')
    ]
    contentType: Annotated[
        Optional[str], Field(None, description='MIME type of the asset.')
    ]
    size: Annotated[Optional[float], Field(None, description='File size in bytes.')]
    extension: Annotated[
        Optional[str], Field(None, description='File extension of the asset.')
    ]
    assetType: Annotated[
        Optional[AssetType], Field(AssetType.Inline, description='Type of the asset.')
    ]
    updatedAt: Annotated[
        Optional[ability.Timestamp],
        Field(
            None,
            description='Last update time corresponding to the new version of the entity in Unix epoch time milliseconds.',
        ),
    ]
    updatedBy: Annotated[
        Optional[str], Field(None, description='User who made the update.')
    ]
    deleted: Annotated[
        Optional[bool],
        Field(
            False,
            description='When `true` indicates the entity has been marked for permanent deletion.',
        ),
    ]
    entityLink: Annotated[
        ability.EntityLink,
        Field(description='Link to the entity that this asset belongs to.'),
    ]


class KnowledgeScope(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    entityTypes: Annotated[
        Optional[List[str]],
        Field(
            None,
            description='Types of entities the agent can access (All, Tables, Glossaries, etc.)',
        ),
    ]
    services: Annotated[
        Optional[List[ability.EntityReference]],
        Field(
            None,
            description='Specific services the agent is limited to (e.g., Snowflake)',
        ),
    ]
    attachments: Annotated[
        Optional[List[Asset]],
        Field(
            None,
            description='Attachment file to parse to extract context for the agent',
        ),
    ]


class DynamicAgent(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[ability.Uuid, Field(description='Unique ID of the Agent')]
    name: Annotated[ability.EntityName, Field(description='A unique name of the Agent')]
    fullyQualifiedName: Annotated[
        Optional[ability.FullyQualifiedEntityName],
        Field(None, description='FullyQualifiedName same as `name`.'),
    ]
    displayName: Annotated[
        Optional[str],
        Field(
            None,
            description="Name used for display purposes. Example 'DWH Slack Agent', 'Governance Expert Agent', etc.",
        ),
    ]
    icon: Annotated[
        Optional[str],
        Field(
            None,
            description='Icon to be used for the agent in the UI. Can be an emoji, URL to an image, or icon name.',
        ),
    ]
    description: Annotated[
        ability.Markdown, Field(description='Description of the Agent and its purpose.')
    ]
    provider: Annotated[
        ability.ProviderType,
        Field(description='Provider of the agent (system-provided or user-created)'),
    ]
    persona: Annotated[
        ability.EntityReference,
        Field(description='AI Persona that defines the system prompt for the agent'),
    ]
    knowledge: Annotated[
        Optional[KnowledgeScope],
        Field(
            None,
            description='Knowledge scope defining what information the agent can access',
        ),
    ]
    abilities: Annotated[
        Optional[List[ability.EntityReference]],
        Field([], description='List of abilities available to the agent'),
    ]
    mode: Annotated[AgentMode, Field(description='Interaction mode for the agent')]
    prompt: Annotated[
        Optional[str],
        Field(None, description='Agent workflow definition as a prompt string'),
    ]
    schedule: Annotated[
        Optional[str],
        Field(
            None, description='Schedule configuration for agent mode (cron expression)'
        ),
    ]
    bot: Annotated[
        Optional[ability.EntityReference],
        Field(
            None,
            description="Bot that will execute this dynamic agent on behalf of users. The bot's JWT token will be used for gRPC requests instead of the user's token. This field is resolved at runtime from botName.",
        ),
    ]
    botName: Annotated[
        Optional[str],
        Field(
            None,
            description='Name of the bot that executes this agent. Used for runtime resolution, allowing the bot to be recreated without breaking the agent reference.',
        ),
    ]
    version: Annotated[
        Optional[ability.EntityVersion],
        Field(None, description='Metadata version of the entity.'),
    ]
    updatedAt: Annotated[
        Optional[ability.Timestamp],
        Field(
            None,
            description='Last update time corresponding to the new version of the entity in Unix epoch time milliseconds.',
        ),
    ]
    updatedBy: Annotated[
        Optional[str], Field(None, description='User who made the update.')
    ]
    href: Annotated[
        Optional[ability.Href],
        Field(None, description='Link to the resource corresponding to this entity.'),
    ]
    owners: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='Owners of this Agent.'),
    ]
    tags: Annotated[
        Optional[List[ability.TagLabel]],
        Field([], description='Tags associated with the Agent.'),
    ]
    changeDescription: Annotated[
        Optional[ability.ChangeDescription],
        Field(None, description='Change that lead to this version of the entity.'),
    ]
    incrementalChangeDescription: Annotated[
        Optional[ability.ChangeDescription],
        Field(
            None,
            description='Entity extension data with custom attributes added to the entity.',
        ),
    ]
    extension: Annotated[
        Optional[ability.EntityExtension],
        Field(
            None,
            description='Entity extension data with custom attributes added to the entity.',
        ),
    ]
    reviewers: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='User references of the reviewers for this agent.'),
    ]
    entityStatus: Annotated[
        Optional[ability.Status],
        Field(ability.Status.Approved, description='Status of the agent.'),
    ]
    followers: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='Followers of this entity.'),
    ]
    deleted: Annotated[
        Optional[bool],
        Field(
            False, description='When `true` indicates the entity has been soft deleted.'
        ),
    ]
    strategy: Annotated[
        Optional[ability.EntityReference],
        Field(
            None,
            description='Reference to an Agent Strategy Template that this agent is based on',
        ),
    ]
