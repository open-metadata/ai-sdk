# generated by datamodel-codegen:
#   filename:  llmModel.json
#   timestamp: 2026-02-01T09:44:00+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, ConfigDict, Field
from typing_extensions import Annotated

from . import ability, aiApplication


class GovernanceStatus(Enum):
    Approved = 'Approved'
    PendingReview = 'PendingReview'
    Rejected = 'Rejected'
    Unauthorized = 'Unauthorized'


class ModelType(Enum):
    BaseModel = 'BaseModel'
    FineTuned = 'FineTuned'
    Quantized = 'Quantized'
    Distilled = 'Distilled'
    Adapter = 'Adapter'
    Custom = 'Custom'


class ModelCapability(Enum):
    TextGeneration = 'TextGeneration'
    CodeGeneration = 'CodeGeneration'
    Embeddings = 'Embeddings'
    Chat = 'Chat'
    Vision = 'Vision'
    Audio = 'Audio'
    FunctionCalling = 'FunctionCalling'
    ToolUse = 'ToolUse'


class TrainingType(Enum):
    FullFineTune = 'FullFineTune'
    LoRA = 'LoRA'
    QLoRA = 'QLoRA'
    PrefixTuning = 'PrefixTuning'
    PromptTuning = 'PromptTuning'
    RLHF = 'RLHF'


class DateRange(BaseModel):
    start: Optional[ability.Timestamp] = None
    end: Optional[ability.Timestamp] = None


class SensitivityLevel(Enum):
    Public = 'Public'
    Internal = 'Internal'
    Confidential = 'Confidential'
    Restricted = 'Restricted'


class DataLineageItem(BaseModel):
    dataset: Optional[ability.EntityReference] = None
    recordCount: Annotated[
        Optional[int],
        Field(None, description='Number of records used from this dataset'),
    ]
    dateRange: Optional[DateRange] = None
    columns: Annotated[
        Optional[List[str]], Field(None, description='Columns used from the dataset')
    ]
    piiHandling: Annotated[
        Optional[str], Field(None, description='How PII was handled in this dataset')
    ]
    dataTransformations: Annotated[
        Optional[List[str]],
        Field(None, description='Transformations applied to the data'),
    ]
    sensitivityLevel: Optional[SensitivityLevel] = None


class TrainingPeriod(BaseModel):
    startDate: Optional[ability.Timestamp] = None
    endDate: Optional[ability.Timestamp] = None
    durationHours: Optional[float] = None


class TrainingCost(BaseModel):
    totalCost: Optional[float] = None
    currency: Optional[str] = 'USD'
    computeHours: Optional[float] = None
    resourceType: Optional[str] = None


class Hyperparameters(BaseModel):
    learningRate: Optional[float] = None
    batchSize: Optional[int] = None
    epochs: Optional[int] = None
    optimizer: Optional[str] = None
    warmupSteps: Optional[int] = None
    weightDecay: Optional[float] = None


class TrainingMetrics(BaseModel):
    finalLoss: Optional[float] = None
    accuracy: Optional[float] = None
    perplexity: Optional[float] = None
    validationLoss: Optional[float] = None


class AccuracyMetrics(BaseModel):
    accuracy: Optional[float] = None
    precision: Optional[float] = None
    recall: Optional[float] = None
    f1Score: Optional[float] = None
    bleuScore: Optional[float] = None
    rougeScore: Optional[float] = None


class DimensionScores(BaseModel):
    gender: Optional[float] = None
    race: Optional[float] = None
    age: Optional[float] = None
    religion: Optional[float] = None
    disability: Optional[float] = None
    nationality: Optional[float] = None
    socioeconomic: Optional[float] = None


class BiasMetrics(BaseModel):
    overallBiasScore: Annotated[
        Optional[float],
        Field(None, description='Overall bias score 0-1, higher = more biased'),
    ]
    demographicParity: Optional[float] = None
    equalizedOdds: Optional[float] = None
    disparateImpact: Optional[float] = None
    dimensionScores: Optional[DimensionScores] = None
    testMethod: Optional[str] = None
    testDataset: Optional[ability.EntityReference] = None


class FairnessMetrics(BaseModel):
    groupFairness: Optional[float] = None
    individualFairness: Optional[float] = None
    counterfactualFairness: Optional[float] = None


class RobustnessMetrics(BaseModel):
    adversarialRobustness: Optional[float] = None
    outlierSensitivity: Optional[float] = None
    noiseRobustness: Optional[float] = None


class SafetyMetrics(BaseModel):
    toxicityScore: Optional[float] = None
    harmfulContentRate: Optional[float] = None
    piiLeakageRisk: Optional[float] = None


class ModelEvaluation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    evaluatedAt: Optional[ability.Timestamp] = None
    evaluationDataset: Optional[ability.EntityReference] = None
    accuracyMetrics: Optional[AccuracyMetrics] = None
    biasMetrics: Annotated[
        Optional[BiasMetrics],
        Field(None, description='LLM BIAS EVALUATION - critical for governance'),
    ]
    fairnessMetrics: Optional[FairnessMetrics] = None
    robustnessMetrics: Optional[RobustnessMetrics] = None
    safetyMetrics: Optional[SafetyMetrics] = None


class ModelSpecifications(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    contextWindow: Annotated[
        Optional[int], Field(None, description='Context window size in tokens')
    ]
    maxOutputTokens: Annotated[
        Optional[int], Field(None, description='Maximum output tokens')
    ]
    parametersCount: Annotated[
        Optional[str],
        Field(None, description="Number of parameters (e.g., '7B', '70B', '175B')"),
    ]
    architecture: Annotated[
        Optional[str],
        Field(
            None, description="Model architecture (e.g., 'Transformer', 'GPT', 'BERT')"
        ),
    ]
    quantization: Annotated[
        Optional[str], Field(None, description='Quantization method if applicable')
    ]


class CostMetrics(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    inputCostPer1kTokens: Annotated[
        Optional[float], Field(None, description='Cost per 1000 input tokens')
    ]
    outputCostPer1kTokens: Annotated[
        Optional[float], Field(None, description='Cost per 1000 output tokens')
    ]
    currency: Optional[str] = 'USD'
    estimatedMonthlyUsage: Annotated[
        Optional[int], Field(None, description='Estimated monthly token usage')
    ]
    estimatedMonthlyCost: Annotated[
        Optional[float], Field(None, description='Estimated monthly cost')
    ]


class DeploymentType(Enum):
    API = 'API'
    SelfHosted = 'SelfHosted'
    Hybrid = 'Hybrid'
    OnPremise = 'OnPremise'


class DeploymentInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    deploymentType: Optional[DeploymentType] = None
    endpoint: Annotated[
        Optional[str], Field(None, description='API endpoint for the model')
    ]
    region: Annotated[Optional[str], Field(None, description='Deployment region')]
    availabilityZones: Optional[List[str]] = None


class TrainingMetadata(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    baseModel: Annotated[
        Optional[str],
        Field(None, description='Base model this was trained/fine-tuned from'),
    ]
    trainingType: Optional[TrainingType] = None
    trainingDatasets: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='Datasets used for training - KEY FOR DATA LINEAGE'),
    ]
    validationDatasets: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='Datasets used for validation'),
    ]
    dataLineage: Annotated[
        Optional[List[DataLineageItem]],
        Field(
            None,
            description='Detailed data lineage for training - tracks exactly what data was used',
        ),
    ]
    trainingPeriod: Optional[TrainingPeriod] = None
    trainingCost: Optional[TrainingCost] = None
    hyperparameters: Annotated[
        Optional[Hyperparameters],
        Field(None, description='Hyperparameters used for training'),
    ]
    trainingMetrics: Annotated[
        Optional[TrainingMetrics],
        Field(None, description='Metrics from training process'),
    ]
    trainedBy: Optional[str] = None
    trainingJobId: Optional[str] = None


class LLMModel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[ability.Uuid, Field(description='Unique identifier of the LLM Model')]
    name: Annotated[
        ability.EntityName, Field(description='Name that identifies this LLM Model')
    ]
    fullyQualifiedName: Annotated[
        Optional[ability.FullyQualifiedEntityName],
        Field(None, description='Fully qualified name of the LLM Model'),
    ]
    displayName: Annotated[
        Optional[str], Field(None, description='Display name for the LLM Model')
    ]
    description: Annotated[
        Optional[ability.Markdown],
        Field(
            None,
            description='Description of the LLM Model, its purpose, and capabilities',
        ),
    ]
    service: Annotated[
        Optional[ability.EntityReference],
        Field(
            None,
            description='OPTIONAL reference to LLMService where this model is hosted',
        ),
    ]
    modelType: ModelType
    baseModel: Annotated[
        str,
        Field(
            description="Base model name (e.g., 'gpt-4', 'claude-3-opus', 'llama-2-70b')"
        ),
    ]
    modelVersion: Annotated[
        Optional[str], Field(None, description='Version of the model')
    ]
    modelProvider: Annotated[
        Optional[str],
        Field(None, description="Model provider (e.g., 'OpenAI', 'Anthropic', 'Meta')"),
    ]
    providerModelId: Annotated[
        Optional[str], Field(None, description="Provider's internal model ID")
    ]
    capabilities: Annotated[
        Optional[List[ModelCapability]],
        Field(None, description='Capabilities of this model'),
    ]
    modelSpecifications: Optional[ModelSpecifications] = None
    trainingMetadata: Optional[TrainingMetadata] = None
    modelEvaluation: Optional[ModelEvaluation] = None
    usedByAgents: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='AI Agents that use this model'),
    ]
    governanceStatus: Annotated[
        Optional[GovernanceStatus],
        Field(
            None, description='Governance status - tracks unauthorized/shadow AI models'
        ),
    ]
    certifications: Annotated[
        Optional[List[str]],
        Field(None, description='Certifications this model has received'),
    ]
    regulatoryCompliance: Annotated[
        Optional[List[str]],
        Field(None, description='Regulatory compliance standards met'),
    ]
    costMetrics: Optional[CostMetrics] = None
    deploymentInfo: Optional[DeploymentInfo] = None
    owners: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='Owners of this LLM Model'),
    ]
    followers: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='Followers of this LLM Model'),
    ]
    domain: Annotated[
        Optional[ability.EntityReference],
        Field(None, description='Domain the LLM Model belongs to'),
    ]
    dataProducts: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='Data products this model is part of'),
    ]
    tags: Annotated[
        Optional[List[ability.TagLabel]],
        Field(None, description='Tags for this LLM Model'),
    ]
    version: Annotated[
        Optional[ability.EntityVersion],
        Field(None, description='Metadata version of the entity'),
    ]
    updatedAt: Annotated[
        Optional[ability.Timestamp],
        Field(None, description='Last update time in Unix epoch milliseconds'),
    ]
    updatedBy: Annotated[
        Optional[str], Field(None, description='User who made the update')
    ]
    href: Annotated[
        Optional[ability.Href], Field(None, description='Link to this resource')
    ]
    changeDescription: Annotated[
        Optional[ability.ChangeDescription],
        Field(None, description='Change that led to this version'),
    ]
    incrementalChangeDescription: Annotated[
        Optional[ability.ChangeDescription],
        Field(None, description='Change that led to this version'),
    ]
    deleted: Annotated[
        Optional[bool],
        Field(
            False, description='When true, indicates the entity has been soft deleted'
        ),
    ]
    certification: Optional[aiApplication.AssetCertification] = None
    extension: Annotated[
        Optional[ability.EntityExtension],
        Field(None, description='Entity extension data with custom attributes'),
    ]
    domains: Annotated[
        Optional[ability.EntityReferenceList],
        Field(None, description='Domains the LLMModel belongs to'),
    ]
    votes: Annotated[
        Optional[aiApplication.Votes], Field(None, description='Votes on the entity')
    ]
    lifeCycle: Annotated[
        Optional[aiApplication.LifeCycle],
        Field(None, description='Life Cycle properties of the entity'),
    ]
    sourceHash: Annotated[
        Optional[str],
        Field(
            None, description='Source hash of the entity', max_length=32, min_length=1
        ),
    ]
