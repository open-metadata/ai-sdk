# generated by datamodel-codegen:
#   filename:  agentStrategy.json
#   timestamp: 2026-02-01T09:44:00+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, List, Optional
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field
from typing_extensions import Annotated

from . import ability


class AgentNodeType(Enum):
    DO_NOTHING = 'DO_NOTHING'
    NODE_UPDATE_PROMPT = 'NODE_UPDATE_PROMPT'
    LLM_REQUEST = 'LLM_REQUEST'
    LLM_REQUEST_ONLY_CALLING_TOOLS = 'LLM_REQUEST_ONLY_CALLING_TOOLS'
    LLM_REQUEST_FORCE_ONE_TOOL = 'LLM_REQUEST_FORCE_ONE_TOOL'
    LLM_REQUEST_STRUCTURED = 'LLM_REQUEST_STRUCTURED'
    LLM_REQUEST_STREAMING = 'LLM_REQUEST_STREAMING'
    LLM_REQUEST_STREAMING_SEND_RESULT = 'LLM_REQUEST_STREAMING_SEND_RESULT'
    LLM_REQUEST_MULTIPLE = 'LLM_REQUEST_MULTIPLE'
    LLM_MODERATE_MESSAGE = 'LLM_MODERATE_MESSAGE'
    LLM_COMPRESS_HISTORY = 'LLM_COMPRESS_HISTORY'
    EXECUTE_TOOL = 'EXECUTE_TOOL'
    EXECUTE_TOOLS_AND_SEND_RESULT = 'EXECUTE_TOOLS_AND_SEND_RESULT'
    EXECUTE_MULTIPLE_TOOLS = 'EXECUTE_MULTIPLE_TOOLS'
    EXECUTE_SINGLE_TOOL = 'EXECUTE_SINGLE_TOOL'
    CAPTURE_AND_REPORT_TOOL_RESULT = 'CAPTURE_AND_REPORT_TOOL_RESULT'
    SEND_TOOL_RESULT = 'SEND_TOOL_RESULT'
    SEND_MULTIPLE_TOOL_RESULTS = 'SEND_MULTIPLE_TOOL_RESULTS'
    NODE_SET_STRUCTURED_OUTPUT = 'NODE_SET_STRUCTURED_OUTPUT'
    CUSTOM_NODE = 'CUSTOM_NODE'
    START_NODE = 'START_NODE'
    FINISH_NODE = 'FINISH_NODE'


class Type(Enum):
    STRING = 'STRING'
    MESSAGE = 'MESSAGE'
    MESSAGE_RESPONSE = 'MESSAGE_RESPONSE'
    MESSAGE_RESPONSE_LIST = 'MESSAGE_RESPONSE_LIST'
    MESSAGE_ASSISTANT = 'MESSAGE_ASSISTANT'
    TOOL_CALL = 'TOOL_CALL'
    TOOL_CALL_LIST = 'TOOL_CALL_LIST'
    TOOL_RESULT = 'TOOL_RESULT'
    TOOL_RESULT_LIST = 'TOOL_RESULT_LIST'
    STRUCTURED_DATA = 'STRUCTURED_DATA'
    RESULT_STRUCTURED_RESPONSE = 'RESULT_STRUCTURED_RESPONSE'
    STREAM = 'STREAM'
    FLOW_STREAM_FRAME = 'FLOW_STREAM_FRAME'
    FLOW_GENERIC = 'FLOW_GENERIC'
    MODERATED_MESSAGE = 'MODERATED_MESSAGE'
    SAFE_TOOL_RESULT = 'SAFE_TOOL_RESULT'
    SAFE_TOOL_RESULT_SUCCESS = 'SAFE_TOOL_RESULT_SUCCESS'
    SAFE_TOOL_RESULT_FAILURE = 'SAFE_TOOL_RESULT_FAILURE'
    BOOLEAN = 'BOOLEAN'
    NUMBER = 'NUMBER'
    JSON_OBJECT = 'JSON_OBJECT'
    GENERIC_TYPE = 'GENERIC_TYPE'
    VOID = 'VOID'


class NodeIOSchema(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Annotated[Type, Field(description='The data type of the input/output')]
    description: Annotated[
        Optional[str],
        Field(None, description='Human-readable description of this input/output'),
    ]
    required: Annotated[
        Optional[bool], Field(True, description='Whether this input is required')
    ]
    structuredSchema: Annotated[
        Optional[Any], Field(None, description='JSON schema for structured data types.')
    ]


class NodePosition(BaseModel):
    x: Optional[float] = None
    y: Optional[float] = None


class EdgeCondition(Enum):
    ON_TOOL_CALL = 'ON_TOOL_CALL'
    ON_ASSISTANT_MESSAGE = 'ON_ASSISTANT_MESSAGE'
    ON_SUCCESS = 'ON_SUCCESS'
    ON_ERROR = 'ON_ERROR'
    ALWAYS = 'ALWAYS'
    CUSTOM_CONDITION = 'CUSTOM_CONDITION'


class AgentNode(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[
        Optional[UUID], Field(None, description='Unique identifier for the node')
    ]
    name: Annotated[str, Field(description='Human-readable name for the node')]
    displayName: Annotated[
        Optional[str], Field(None, description='Display Name for the Node.')
    ]
    description: Annotated[
        Optional[str], Field(None, description='Description for the Node.')
    ]
    nodeType: Annotated[
        Optional[AgentNodeType], Field(None, description='Type of the node')
    ]
    icon: Annotated[Optional[str], Field(None, description='Icon for the node')]
    categoryLabel: Annotated[
        Optional[str], Field(None, description='Category label for the node')
    ]
    inputSchema: Annotated[
        Optional[NodeIOSchema], Field(None, description='Input Schema for Node')
    ]
    outputSchema: Annotated[
        Optional[NodeIOSchema], Field(None, description='Output Schema for Node')
    ]
    configurationSchema: Annotated[
        Optional[Any], Field(None, description='Node-specific configuration parameters')
    ]
    defaultConfiguration: Annotated[
        Optional[Any], Field(None, description='Node-specific configuration parameters')
    ]
    position: Optional[NodePosition] = None
    provider: Annotated[
        Optional[ability.ProviderType],
        Field(
            ability.ProviderType.user,
            description='Provider of the Ability implementation',
        ),
    ]


class AgentEdge(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    source: Annotated[UUID, Field(description='Source node ID')]
    target: Annotated[UUID, Field(description='Target node ID')]
    condition: Annotated[
        EdgeCondition, Field(description='Condition for this edge to be taken')
    ]
    conditionExpression: Annotated[
        Optional[str],
        Field(
            None,
            description='Custom condition expression if condition is CUSTOM_CONDITION',
        ),
    ]
    transformation: Annotated[
        Optional[str],
        Field(None, description='Optional transformation function to apply to data'),
    ]


class AgentStrategy(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[ability.Uuid, Field(description='Unique ID of the Agent Strategy')]
    name: Annotated[
        ability.EntityName, Field(description='A unique name of the Agent Strategy')
    ]
    fullyQualifiedName: Annotated[
        Optional[ability.FullyQualifiedEntityName],
        Field(None, description='FullyQualifiedName same as `name`.'),
    ]
    displayName: Annotated[
        Optional[str],
        Field(
            None,
            description="Name used for display purposes. Example 'Simple Q&A', 'Tool Calling Agent', etc.",
        ),
    ]
    description: Annotated[
        Optional[ability.Markdown],
        Field(None, description='Description of the strategy and its use case.'),
    ]
    nodes: Annotated[
        Optional[List[AgentNode]],
        Field(
            None, description="Workflow nodes that define the agent's execution steps"
        ),
    ]
    edges: Annotated[
        Optional[List[AgentEdge]],
        Field(
            None,
            description='Workflow edges that define transitions and data flow between nodes',
        ),
    ]
    provider: Annotated[
        Optional[ability.ProviderType],
        Field(
            ability.ProviderType.user,
            description='Provider of the Ability implementation',
        ),
    ]
    tags: Annotated[
        Optional[List[ability.TagLabel]],
        Field([], description='Tags for this Agent Strategy.'),
    ]
    owner: Annotated[
        Optional[ability.EntityReference],
        Field(None, description='Owner of this Agent Strategy'),
    ]
    version: Annotated[
        Optional[ability.EntityVersion],
        Field(None, description='Metadata version of the entity.'),
    ]
    updatedAt: Annotated[
        Optional[ability.Timestamp],
        Field(
            None,
            description='Last update time corresponding to the new version of the entity in Unix epoch time milliseconds.',
        ),
    ]
    updatedBy: Annotated[
        Optional[str], Field(None, description='User who made the update.')
    ]
    href: Annotated[
        Optional[ability.Href],
        Field(None, description='Link to the resource corresponding to this entity.'),
    ]
    changeDescription: Annotated[
        Optional[ability.ChangeDescription],
        Field(None, description='Change that lead to this version of the entity.'),
    ]
    incrementalChangeDescription: Annotated[
        Optional[ability.ChangeDescription],
        Field(None, description='Change that lead to this version of the entity.'),
    ]
    deleted: Annotated[
        Optional[bool],
        Field(
            False, description='When `true` indicates the entity has been soft deleted.'
        ),
    ]
