# generated by datamodel-codegen:
#   filename:  agentExecution.json
#   timestamp: 2026-02-01T09:44:00+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field
from typing_extensions import Annotated

from . import ability


class Environment(Enum):
    Development = 'Development'
    Staging = 'Staging'
    Production = 'Production'


class ExecutionStatus(Enum):
    Running = 'Running'
    Success = 'Success'
    Failed = 'Failed'
    Timeout = 'Timeout'
    Cancelled = 'Cancelled'
    PartialSuccess = 'PartialSuccess'


class ModelCall(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    model: Annotated[
        Optional[ability.EntityReference], Field(None, description='LLM Model used')
    ]
    prompt: Annotated[
        Optional[str], Field(None, description='Prompt sent to the model')
    ]
    response: Annotated[
        Optional[str], Field(None, description='Response from the model')
    ]
    inputTokens: Annotated[
        Optional[int], Field(None, description='Number of input tokens')
    ]
    outputTokens: Annotated[
        Optional[int], Field(None, description='Number of output tokens')
    ]
    latencyMs: Annotated[
        Optional[float], Field(None, description='Latency in milliseconds')
    ]
    cost: Annotated[Optional[float], Field(None, description='Cost for this call')]
    timestamp: Optional[ability.Timestamp] = None
    purpose: Annotated[
        Optional[str], Field(None, description='Purpose of this model call')
    ]


class AccessType(Enum):
    Read = 'Read'
    Write = 'Write'
    Update = 'Update'
    Delete = 'Delete'


class SensitivityLevel(Enum):
    Public = 'Public'
    Internal = 'Internal'
    Confidential = 'Confidential'
    Restricted = 'Restricted'


class DataAccess(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    dataSource: Annotated[
        ability.EntityReference,
        Field(description='Reference to the data source (Table, Dashboard, etc.)'),
    ]
    accessType: Annotated[AccessType, Field(description='Type of access')]
    columns: Annotated[
        Optional[List[str]], Field(None, description='Specific columns accessed')
    ]
    recordCount: Annotated[
        Optional[int], Field(None, description='Number of records accessed')
    ]
    query: Annotated[
        Optional[str], Field(None, description='Query executed (if applicable)')
    ]
    timestamp: Optional[ability.Timestamp] = None
    piiAccessed: Annotated[
        Optional[bool], Field(None, description='Whether PII data was accessed')
    ]
    sensitivityLevel: Optional[SensitivityLevel] = None


class ToolCall(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    tool: Annotated[
        Optional[ability.EntityReference],
        Field(None, description='Reference to MCP Tool or custom tool'),
    ]
    parameters: Annotated[
        Optional[Dict[str, Any]],
        Field(None, description='Parameters passed to the tool'),
    ]
    result: Annotated[Optional[str], Field(None, description='Result from the tool')]
    success: Annotated[
        Optional[bool], Field(None, description='Whether the tool call succeeded')
    ]
    latencyMs: Annotated[
        Optional[float], Field(None, description='Latency in milliseconds')
    ]
    timestamp: Optional[ability.Timestamp] = None
    errorMessage: Annotated[
        Optional[str], Field(None, description='Error message if failed')
    ]


class ExecutionMetrics(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    totalTokens: Annotated[
        Optional[int],
        Field(None, description='Total tokens used across all model calls'),
    ]
    totalCost: Annotated[Optional[float], Field(None, description='Total cost in USD')]
    totalLatencyMs: Annotated[
        Optional[float], Field(None, description='Total execution time in milliseconds')
    ]
    modelCallCount: Annotated[
        Optional[int], Field(None, description='Number of model calls made')
    ]
    toolCallCount: Annotated[
        Optional[int], Field(None, description='Number of tool calls made')
    ]
    dataSourcesAccessed: Annotated[
        Optional[int], Field(None, description='Number of unique data sources accessed')
    ]
    piiDataAccessed: Annotated[
        Optional[bool], Field(None, description='Whether any PII data was accessed')
    ]


class Severity(Enum):
    Low = 'Low'
    Medium = 'Medium'
    High = 'High'
    Critical = 'Critical'


class ComplianceCheck(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    checkName: Annotated[
        Optional[str], Field(None, description='Name of the compliance check')
    ]
    passed: Annotated[
        Optional[bool], Field(None, description='Whether the check passed')
    ]
    details: Annotated[
        Optional[str], Field(None, description='Details about the check result')
    ]
    severity: Optional[Severity] = None


class AgentExecution(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[
        Optional[ability.Uuid],
        Field(None, description='Unique identifier of the Agent Execution'),
    ]
    agent: Annotated[
        ability.EntityReference, Field(description='AI Agent that was executed')
    ]
    agentId: Annotated[
        ability.Uuid, Field(description='ID of the AI Agent (for indexing)')
    ]
    timestamp: Annotated[
        ability.Timestamp, Field(description='Execution start timestamp')
    ]
    endTimestamp: Annotated[
        Optional[ability.Timestamp], Field(None, description='Execution end timestamp')
    ]
    status: ExecutionStatus
    input: Annotated[
        Optional[str], Field(None, description='Input provided to the agent')
    ]
    output: Annotated[
        Optional[str], Field(None, description='Output generated by the agent')
    ]
    modelCalls: Annotated[
        Optional[List[ModelCall]],
        Field(None, description='LLM model calls made during execution'),
    ]
    dataAccessed: Annotated[
        Optional[List[DataAccess]],
        Field(
            None, description='Data sources accessed during execution - KEY FOR LINEAGE'
        ),
    ]
    toolCalls: Annotated[
        Optional[List[ToolCall]],
        Field(None, description='Tool calls made during execution'),
    ]
    metrics: Optional[ExecutionMetrics] = None
    errorMessage: Annotated[
        Optional[str], Field(None, description='Error message if execution failed')
    ]
    errorStack: Annotated[Optional[str], Field(None, description='Error stack trace')]
    complianceChecks: Annotated[
        Optional[List[ComplianceCheck]],
        Field(None, description='Compliance checks performed'),
    ]
    executedBy: Annotated[
        Optional[str],
        Field(None, description='User or system that triggered the execution'),
    ]
    sessionId: Annotated[
        Optional[str],
        Field(None, description='Session ID for grouping related executions'),
    ]
    environment: Annotated[
        Optional[Environment],
        Field(None, description='Environment where execution occurred'),
    ]
    agentVersion: Annotated[
        Optional[str], Field(None, description='Version of the agent at execution time')
    ]
    metadata: Annotated[
        Optional[Dict[str, str]],
        Field(None, description='Additional execution metadata'),
    ]
    deleted: Annotated[
        Optional[bool],
        Field(
            False, description='When true, indicates the entity has been soft deleted'
        ),
    ]
